# [Quarkus Kubernetes Extension][quarkus-k8s-extension], Késako ?
Extension that supports automatic generation of manifests for Kubernetes, OpenShift, Knative platforms. It is based on the **_[Dekorate][dekorate]_** lib, 
and configurations (in the form of quarkus properties) supplied by users. \
_In this tutorial we use the Kubernetes platform by default._

Kubernetes manifests are generated at application build (`./gradlew build`) time in `build/kubernetes`

Manifest output directory can be changed :
```properties
quarkus.kubernetes.output-directory=build/k8s
```

You can then apply the generated manifests:
```bash
# Cluster setup for this tutorial
kubectl apply -f k8s/

kubectl apply -f build/k8s/kubernetes.yml
```

> The [Container Image extension][quarkus-container-image-extension] lets you automatically build and push Docker images when deploying them on a target platform.

# Manifests Kubernetes
## Container Image
- The generated docker image of Pod, will take the form : `<DOCKER_HOST_USER>/<APPLICATION_NAME>:<APPLICATION_VERSION>`
- These properties can be overloaded
```properties
quarkus.container-image.group=quarkus #optional, default to the system username
quarkus.container-image.name=demo-app #optional, defaults to the application name
quarkus.container-image.tag=1.0       #optional, defaults to the application version
```
⚠️ _You'll need a quarkus extension for Container Image. We used Jib_

## GitOps compatibility
All k8s objects generated by Quakus contain the following annotations : 
```yaml
metadata:
  annotations:
    app.quarkus.io/build-timestamp: 2023-08-18 - 07:25:56 +0000
```

The values of these annotations are too changeable, due to the fact that applications are too often built (on the dev workstation or on CI). This is problematic with GitOps tools, as these changes will lead to new deployments.

The ideal solution would be to do without it and be compatible with GitOps tools :
```properties
quarkus.kubernetes.idempotent=true
```

## Deployment kind
By default, the generated Pod is controlled by the k8s `Deployment` object. But the following objects can also be used:
- `StatefulSet`
  - `quarkus.kubernetes.deployment-kind=StatefulSet` 
- `Job`
  - [`quarkus.kubernetes.deployment-kind=Job`][job-configuration]
- `CronJob`
  - [`quarkus.kubernetes.deployment-kind=CronJob`][cron-job-configuration]

## Namespace
No namespace is specified in the manifests, so resources will be created in the default namespace. We can specify our own namespaces : 
```properties
quarkus.kubernetes.namespace=tuto-quarkus-k8s
```

## Labels
[Certain labels are recommended by k8s][recommended-labels-k8s], and we can define them as follows: 
```properties
quarkus.kubernetes.part-of=tutorials
quarkus.kubernetes.name=quarkus-k8s   # Generated by default
quarkus.kubernetes.version=1.0
```

We can define our own labels, respecting the format \
We can enclose the key in double quotation marks for greater precision. It will remain mandatory if the key contains the "." character.

Example :
```properties
# Format : quarkus.kubernetes.labels.<KEY>=<VALUE>
quarkus.kubernetes.labels."app.quarkus.io/author"=Kevin.Nzuguem
```

## Annotations
Specifying annotations is very similar to specifying labels.

Example :
```properties
# Format : quarkus.kubernetes.annotations.<KEY>=<VALUE>
quarkus.kubernetes.annotations."app.quarkus.io/position"=1
```

## Environment variables
Three ways to inject environment variables :
- **_env - value_** \
  The value of the environment variable is set directly in the manifest
  ```properties
  # Format : quarkus.kubernetes.env.vars.<ENV_KEY>=<ENV_VALUE>
  quarkus.kubernetes.env.vars.greeting-name=RESTEasy Reactive EnvValue
  ```
  ```yaml
  # Result
  env:
  - name: GREETING_NAME
    value: RESTEasy Reactive EnvValue
  ```

- **_env - valueFrom_** \
  The value of the environment variable is extracted either from a `Secret`, a `ConfigMap` or a Pod field
  ```properties
  # ConfigMap
  # Format : quarkus.kubernetes.env.mapping.<ENV_KEY>.from-configmap=<NAME OF CONFIGMAP>
  quarkus.kubernetes.env.mapping.greeting-name-cm.from-configmap=tuto-quarkus-k8s-greeting-cm
  # Format : quarkus.kubernetes.env.mapping.<ENV_KEY>.with-key=<KEY DATA ON CONFIGMAP>
  quarkus.kubernetes.env.mapping.greeting-name-cm.with-key=GREETING_NAME_CM
  
  # Secret
  # Format : quarkus.kubernetes.env.mapping.<ENV_KEY>.from-secret=<NAME OF SECRET>
  quarkus.kubernetes.env.mapping.greeting-name-secret.from-secret=tuto-quarkus-k8s-greeting-secret
  # Format : quarkus.kubernetes.env.mapping.<ENV_KEY>.with-key=<KEY DATA ON SECRET>
  quarkus.kubernetes.env.mapping.greeting-name-secret.with-key=GREETING_NAME_SECRET
  
  # Field
  # Format : quarkus.kubernetes.env.fields.<ENV_KEY>=<POD FIELD PATH>
  quarkus.kubernetes.env.fields.instance-name=metadata.name
  ```
  ```yaml
  # Result
  env:
  - name: GREETING_NAME_SECRET
    valueFrom:
      secretKeyRef:
        key: GREETING_NAME_SECRET
        name: tuto-quarkus-k8s-greeting-secret
  - name: GREETING_NAME_CM
    valueFrom:
      configMapKeyRef:
        key: GREETING_NAME_CM
        name: tuto-quarkus-k8s-greeting-cm
  - name: GREETING_NAME
    value: RESTEasy Reactive EnvValue
  - name: INSTANCE_NAME
    valueFrom:
      fieldRef:
        fieldPath: metadata.name
  ```
  
- **_envFrom_** \
  Environment variables (**_key and value_**) are extracted from either `ConfigMap` or `Secret` 
  ```properties
  # ConfigMap
  # Format: quarkus.kubernetes.env.configmaps=<LIST OF CONFIGMAPS. Separate by ",">
  quarkus.kubernetes.env.configmaps=tuto-quarkus-k8s-greeting-cm
  
  # Secret
  # Format: quarkus.kubernetes.env.secrets=<LIST OF SECRETS. Separate by ",">
  quarkus.kubernetes.env.secrets=tuto-quarkus-k8s-greeting-secret
  ```
  ```yaml
  # Result
  envFrom:
  - secretRef:
      name: tuto-quarkus-k8s-greeting-secret
  - configMapRef:
      name: tuto-quarkus-k8s-greeting-cm
  ```
  
## Volumes
Some supported volumes :
- **_Secret_**
  ```properties
  # Format : quarkus.kubernetes.secret-volumes.<VOLUME_NAME>.secret-name=<NAME OF SECRET> 
  quarkus.kubernetes.secret-volumes.secret-volume.secret-name=tuto-quarkus-k8s-greeting-secret
  
  # Volume Mounting
  # Format : quarkus.kubernetes.mounts.<VOLUME_NAME>.path=<MOUNT_PATH> 
  quarkus.kubernetes.mounts.secret-volume.path=/tmp/secret
  ```
  ```yaml
  # Result
  volumes:
  - name: secret-volume
    secret:
      secretName: tuto-quarkus-k8s-greeting-secret
  ...
  containers:
  - volumeMounts:
    - mountPath: /tmp/secret
      name: secret-volume
  ```
  
- **_ConfigMap_**
  ```properties
  # Format : quarkus.kubernetes.config-map-volumes.<VOLUME_NAME>.config-map-name=<NAME OF CONFIGMAP> 
  quarkus.kubernetes.config-map-volumes.cm-volume.config-map-name=tuto-quarkus-k8s-greeting-cm
  
  # Volume Mounting
  # Format : quarkus.kubernetes.mounts.<VOLUME_NAME>.path=<MOUNT_PATH> 
  quarkus.kubernetes.mounts.cm-volume.path=/tmp/cm
  ```
    ```yaml
  # Result
  volumes:
  - name: cm-volume
    configMap:
      name: tuto-quarkus-k8s-greeting-cm
  ...
  containers:
  - volumeMounts:
    - mountPath: /tmp/cm
      name: cm-volume
  ```

- **_Persistent Volume Claim_**
  ```properties
  # Format : quarkus.kubernetes.pvc-volumes.<VOLUME_NAME>.claim-name=<NAME OF PVC> 
  quarkus.kubernetes.pvc-volumes.pvc-volume.claim-name=tuto-quarkus-k8s-example-pvc 
  
  # Volume Mounting
  # Format : quarkus.kubernetes.mounts.<VOLUME_NAME>.path=<MOUNT_PATH> 
  quarkus.kubernetes.mounts.pvc-volume.path=/tmp/pvc
  ```
  ```yaml
  # Result
  volumes:
  - name: pvc-volume
    persistentVolumeClaim:
      claimName: tuto-quarkus-k8s-greeting-pvc
  ...
  containers:
  - volumeMounts:
    - mountPath: /tmp/pvc
      name: pvc-volume
  ```

- **_Empty Dir_**
  ```properties
  # Format : quarkus.kubernetes.empty-dir-volumes=<LIST OF VOLUME_NAME. Separate by ","> 
  quarkus.kubernetes.empty-dir-volumes=empty-volume
  
  # Volume Mounting
  # Format : quarkus.kubernetes.mounts.<VOLUME_NAME>.path=<MOUNT_PATH> 
  quarkus.kubernetes.mounts.empty-volume.path=/tmp/empty
  ```
  ```yaml
  # Result
  volumes:
  - name: empty-volume
    emptyDir: {}
  ...
  containers:
  - volumeMounts:
    - mountPath: /tmp/pvc
      name: pvc-volume
  ```
  
> In addition to defining the volumes and their mounts (`Secret` & `ConfigMap`), if you need to use them as an application configuration (**_SmallRye Config_**), you'll need to define the `SMALLRYE_CONFIG_LOCATIONS=/tmp/cm,/temp/secret` variable.
>
> With the quarkus kubernetes extension, these steps (_volume definition, mounting and definition of `SMALLRYE_CONFIG_LOCATIONS`_) can be combined in a single configuration :  
>```properties
>  # Format: quarkus.kubernetes.app-secret=<NAME OF SECRET> 
>  quarkus.kubernetes.app-secret=tuto-quarkus-k8s-greeting-secret
>  # Format: quarkus.kubernetes.app-config-map=<NAME OF CONFIGMAP> 
>  quarkus.kubernetes.app-config-map=tuto-quarkus-k8s-greeting-cm
>```

## Replicas
Par défaut le nombre de replicas est défini à 1. Mais nous pouvons l'étendre via :
```properties
quarkus.kubernetes.replicas=3
```
_This configuration only concerns `Deployment` and `StatefulSet`_

## Health Check Probes
The strength of quarkus lies in its extensions and the way they can be composed.

By adding the `smallrye-health` extension, all health probes will be present by default in the application and in k8s manifests.

```yaml
# Result
containers:
- livenessProbe:
    failureThreshold: 3
    httpGet:
      path: /q/health/live
      port: 8080
      scheme: HTTP
    initialDelaySeconds: 5
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 10
  
  readinessProbe:
    failureThreshold: 3
    httpGet:
      path: /q/health/ready
      port: 8080
      scheme: HTTP
    initialDelaySeconds: 10
    periodSeconds: 5
    successThreshold: 1
    timeoutSeconds: 10
  startupProbe:
    failureThreshold: 3
    httpGet:
      path: /q/health/started
      port: 8080
      scheme: HTTP
    initialDelaySeconds: 5
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 10
```
To customize these probes, please refer to the [SmallRye Health documentation][quarkus-smallrye-health-extension].
We can override the default configurations derived from the `kubernetes` + `smallrye-health` extension composition. All configurations are available [here][probes-configuration] \
Example :
```properties
quarkus.kubernetes.readiness-probe.initial-delay=10s # Type is java.time.Duration
quarkus.kubernetes.readiness-probe.period=5s         # Type is java.time.Duration
```

## Resources Management
Resource management is fairly intuitive: 
```properties
quarkus.kubernetes.resources.requests.memory=512Mi
quarkus.kubernetes.resources.requests.cpu=1000m
quarkus.kubernetes.resources.limits.memory=512Mi
```
```yaml
# Result
containers:
- resources:
    limits:
      memory: 512Mi
    requests:
      cpu: 1000m
      memory: 512Mi
```

## Exposing an application
To expose our application via Ingress Resource, simply do
```properties
quarkus.kubernetes.ingress.expose=true
```
```yaml
# Result
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  annotations:
    app.quarkus.io/position: "1"
  labels:
    app.kubernetes.io/name: quarkus-k8s
    app.kubernetes.io/part-of: tutorials
    app.quarkus.io/author: Kevin.Nzuguem
    app.kubernetes.io/managed-by: quarkus
  name: quarkus-k8s
  namespace: tuto-quarkus-k8s
spec:
  rules:
    - http:
        paths:
          - backend:
              service:
                name: quarkus-k8s
                port:
                  name: http
            path: /
            pathType: Prefix
```
We can add configuration to the generated rule. For example, define a `host` or `path`.
> ⚠️ The `path` must correspond to a route exposed by the application, otherwise you'll have to think about rewriting it according to your ingress controller.
```properties
quarkus.kubernetes.ingress.host=prod.svc.url
# The term http in the configuration corresponds to the name of the service port to be exposed
quarkus.kubernetes.ports.http.path=/prod
```
```yaml
# Result
...
rules:
- host: prod.svc.url
  http:
    paths:
      - backend:
          service:
            name: quarkus-k8s
            port:
              name: http
        path: /prod
        pathType: Prefix
```

We can add further rules as follows :
```properties
# Format : quarkus.kubernetes.ingress.rules.<FREE_KEY>.<INGRESS_CONF_KEY>=<INGRESS_CONF_VALUE> 
quarkus.kubernetes.ingress.rules.1.host=<INGRESS_RULE_HOST>
quarkus.kubernetes.ingress.rules.1.path=<INGRESS_RULE_PATH>
quarkus.kubernetes.ingress.rules.1.service-name=<SERVICE_NAME_TO_EXPOSED>
quarkus.kubernetes.ingress.rules.1.service-port-name=<SERVICE_PORT_NAME_TO_EXPOSED>
```

### Securing ingress resources
Securing a resource requires a private key and a TLS certificate (in our case, self-signed). This information must be stored in a TLS Secret. Execute this command:
```shell
# Creation of a private key and a TLS certificate, then stored in a TLS k8s secret
bash k8s/generate-tls-secret.sh   
```
To activate the securing of ingress resources, simply do : 
```properties
# Format : quarkus.kubernetes.ingress.tls.<SECRET_NAME>.enabled=<true | false>
quarkus.kubernetes.ingress.tls.tuto-quarkus-k8s-tls-secret.enabled=true
```
```yaml
# Result
rules:
...
tls:
- secretName: tuto-quarkus-k8s-tls-secret
```

<!-- All resources links -->
[job-configuration]:  https://quarkus.io/guides/deploying-to-kubernetes#quarkus-kubernetes-kubernetes-config_quarkus.kubernetes.job.parallelism
[cron-job-configuration]: https://quarkus.io/guides/deploying-to-kubernetes#quarkus-kubernetes-kubernetes-config_quarkus.kubernetes.cron-job.parallelism
[recommended-labels-k8s]: https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels
[quarkus-k8s-extension]: https://quarkus.io/guides/deploying-to-kubernetes
[dekorate]: https://dekorate.io/
[quarkus-container-image-extension]: https://quarkus.io/guides/container-image
[quarkus-smallrye-health-extension]: https://quarkus.io/guides/smallrye-health
[probes-configuration]: https://quarkus.io/guides/deploying-to-kubernetes#quarkus-kubernetes-kubernetes-config_quarkus.kubernetes.liveness-probe.http-action-port